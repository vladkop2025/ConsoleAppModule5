using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace ConsoleApp
{
    internal class Program
    {
        static void Main(string[] args)
        {
            /* Модуль 5. Методы в C# 
            5.5. Рекурсивные функции

            Что же такое рекурсия?  Простое определение следующее: функция, которая вызывает саму себя. 

            Давайте попробуем представить эхо как циклическую функцию. 

                var str = Console.ReadLine();

                Console.WriteLine("Укажите глубину эха");

                var deep = int.Parse(Console.ReadLine());

                for (int i = 0; i < deep; i++)
                {
                    Echo(str);

                }


            Код вне класса Main

            static void Echo(string saidword)
            {
                Console.WriteLine(saidword);
            }

            Здесь мы не использовали никакой рекурсии, просто вызвали одну и ту же функцию. Но настоящее эхо ведь действительно 
            вызывает само себя. То есть не работает с изначальной «фразой», а отражает «прошлую итерацию». 
            Давайте изменим код нашего метода, для того чтобы добиться этого: 

                Console.WriteLine("Напишите что-то");
                var str = Console.ReadLine();

                Console.WriteLine("Укажите глубину эха");
                var deep = int.Parse(Console.ReadLine());

                Echo(str, deep);

                Console.ReadKey();
            }

            Код вне класса Main

            static void Echo(string phrase, int deep)
            {
                Console.WriteLine(phrase);
            }
    
            Мы не используем цикл в данном случае, просто передаем необходимую длину нашему методу и вызываем его столько, сколько нужно. 
            Сейчас нам выводится изначальная фраза столько раз, сколько мы указали. Но давайте модифицируем её как в настоящем эхе.

            Для этого нам требуется изменять нашу изначальную фразу. Допустим, мы будем убирать из неё две первые буквы, чтобы создавалось 
            ощущение, что она немного неправильно «отражается». 

            Объявим эту переменную и запишем в неё введённую нами строку saidworld:

           Задание 5.5.1 Давайте будем использовать для модификаций переменную modif. Какого типа она будет?

                Ответ: string

                static void Echo(string saidworld, int deep) {
                var modif = saidworld;

            Так как эта переменная передается по значению, мы можем не создавать дополнительную переменную, а работать с этой — данные 
            не изменятся и все будет работать корректно. 

            Задание 5.5.2 Переменная saidworld передается по значению или по ссылке? 

                Ответ: По значению

            Но если вдруг у вас вместо переменной строки появится переменная класса или массив, то ситуация будет иной. 

                Правилом хорошего тона является не модифицировать входные данные никаким образом, даже  если это является безопасным с точки 
                зрения сохранения информации.  Лучше создать дополнительную переменную и всегда иметь возможность посмотреть на «исходные» 
                данные во время работы метода.

            Мы должны убрать две буквы с начала строки. Но если строка всего из двух букв? Тогда ничего работать не будет. 
            А если из одной? То будет ошибка. 
            Для этого нам необходимо проверить нашу входную строку на соответствие: в ней должно быть больше двух букв. 
            Это вопрос к отказоустойчивости нашей программы и работе с ошибками, исключительным поведением, детально мы разберём этот вопрос
            в других модулях. Пока добавим простое условие для нашей строки

                    if (modif.Length > 2)
                    {
                      modif = modif.Remove(0, 2);
                    }

            Если вы выберете строку, напечатаете точку, то сможете посмотреть все доступные методы для работы с этим объектом. Детальнее 
            мы также разберём это в других модулях. Однако вы можете использовать обращения к методам работы к строкам уже сейчас.
            Самые часто используемые методы помечены звездочкой ⭐.

            Далее давайте выведем модифицированную строку. Для красоты добавим к ней многоточие:

                    Console.WriteLine("..." + modif);

            Далее идёт логика нашей рекурсии: если повторений больше 1, то нужно вызвать этот метод ещё раз, но количество вызовов передать ему на 1 меньше.
            Обратите внимание: мы передаем модифицированную строку, а не оригинальную. Эта «модификация» становится новым «оригиналом».

                    if (deep > 1)
                    {
                        Echo(modif, deep - 1);
                    }

            Теперь это похоже на настоящее эхо, не правда ли?

            Код вне класса Main

        static void Echo(string saidworld, int deep)
        {
            var modif = saidworld;
            if (modif.Length > 2)
            {
                modif = modif.Remove(0, 2);
            }

            Console.BackgroundColor = (ConsoleColor)deep;
            Console.WriteLine("..." + modif);

            if (deep > 1)
            {
                Echo(modif, deep - 1);
            }
        }

            Для создания рекурсивной функции должен быть некоторый базовый вариант, например, у нас это модификация строки и вывод 
            её на экран. И, если указать глубину эха 1, то рекурсия просто не вызовется.

            Без базового варианта — тех действий, которые происходят на первой итерации — рекурсия работать не будет. Вызовы «спускаются» 
            нужное количество раз по цепочке до самого первого, а если его не будет, то не будет и рекурсии.

            Самый известный математический пример рекурсии — это расчет факториала числа.

            По сути, это умножение всех чисел до конкретного, которое нас интересует.
            Записывается так: 
            A представляется как: x * (X -1)!

            Запишем этот код, он аналогичен тому, что мы написали, только использует синтаксис C#: 

        static int Factorial(int x)
        {
            if (x == 0)
            {
                return 1;
            }
            else
            {
                return x * Factorial(x - 1);
            }
        }

            Задание 5.5.5 
            Выполните метод, чтобы посчитать факториал 20. Что отобразится на экране?

                Ответ: -2102132736

            Задание 5.5.6
            Подумайте, с чем связан такой результат?

                Ответ: Переполнение типа данных
            
            Дело в том, что факториал — довольно быстро растущая величина. И она быстро выходит за пределы типа int. Потому могут получиться 
            довольно странные результаты. Хорошим вариантом будет указание типа данных больше, чем int, или ограничение на вводимое число. 

            Давайте укажем самый большой тип данных, который покроет наше вычисление. 

            Задание 5.5.7
            Какой это тип данных?

                Ответ: decimal

        static decimal Factorial(int x)
        {
            if (x == 0)
            {
                return 1;
            }
            else
            {
                return x * Factorial(x - 1);
            }
        }

            При работе с рекурсией нужно учитывать подобные моменты. И также обязательно нужно следить за тем, чтобы не было ситуации, 
            когда какая-то итерация «выбивается». Например, на 100-ой итерации нам нужно будет изменить логику, и она не будет повторять
            те же самые действия. Это противоречит принципу рекурсии. Вместо рекурсии можно использовать циклические конструкции  и, 
            как правило, они работают быстрее. Для вычисления рекурсия — не самая оптимальная операция. Но в некоторых ситуациях это 
            довольно изящное и оптимальное решение.
            Реальными задачами могут быть задачи по обходу древовидных представлений и иерархий: файловой структуры, каталогов, списков. 

            Задание 5.5.8
            Необходимо написать рекурсивный метод, который возводит введенное число N типа int в указанную степень pow типа byte.

        private static int PowerUp(int N, byte pow)
        {
            введите код здесь
        }

            Ответ:

        private static int PowerUp(int N, byte pow)
        {
            if (pow == 0)
            {
                return 1;
            }
            else
            {
                if (pow == 1)
                {
                    return N;
                }
                else
                {
                    return N * PowerUp(N, --pow);
                }
            }
        }
    }    
            */
        }
    }
}
